Haskell style guide
===================
Ian D. Bollinger <ian.bollinger@gmail.com>
:icons:
:numbered:
:website: http://asciidoc.org/

Many open-source projects have their own style guide: a set of
conventions, sometimes arbitrary, about how to write code for that
project. It is easier to understand a large project when all its source
code has a consistent style. This document tries to cover the major
areas of formatting and naming. When something is not covered by this
guide, you should stay consistent with a project's existing source code.

:toc:

Formatting
----------

Lines should be no longer than 80 characters
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Lines should not be longer than **80 characters**.

Exceptions
^^^^^^^^^^
* URLs must not be split over multiple lines.
* Markup within [Haddock] comments must sometimes exceed this limit.

Indent with spaces, not tabs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Source files must not contain spaces; use spaces for indenting.
* Indent code blocks with **4 spaces**.
* Indent the `where` keyword **2 spaces** to set it apart from the rest
  of the code, and indent the definitions in a `where` clause 2 spaces.

Examples
^^^^^^^^
```haskell
sayHello :: IO ()
sayHello = do
    name <- getLine
    putStrLn $ greeting name
  where
    greeting name = "Hello, " ++ name ++ "!"
```

```haskell
filter :: (a -> Bool) -> [a] -> [a]
filter _ []     = []
filter p (x : xs)
    | p x       = x : filter p xs
    | otherwise = filter p xs
```

Separate top-level definitions with a blank line
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Use one blank line between top-level definitions.
* Do not place blank lines between type signatures and function
  definitions.
* Add one blank line between functions in a type class instance
  declaration if the functions bodies are large.

Whitespace
~~~~~~~~~~

Surround binary operators with a single space on either side; this is
optional for arithmetic operators.

No space after a lambda
~~~~~~~~~~~~~~~~~~~~~~~

Do not insert a space after the lambda symbol (`\`).

Lines must not have trailing spaces
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Remove any whitespace at the end of each line of source code.

Align data type constructors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Align constructors in a data type definition.

Examples
^^^^^^^^
```haskell
data Tree a = Branch !a !(Tree a) !(Tree a)
            | Leaf
```

For long type names, the following formatting is also acceptable:

```haskell
data HttpException
    = InvalidStatusCode Int
    | MissingContentHeader
```

Format records as follows:

```haskell
data Person = Person
    { firstName :: !String  -- ^ First name
    , lastName  :: !String  -- ^ Last name
    , age       :: !Int     -- ^ Age
    } deriving (Eq, Show)
```

Align elements in a list
~~~~~~~~~~~~~~~~~~~~~~~~

Align the elements in the list.

Examples
^^^^^^^^
```haskell
exceptions =
    [ InvalidStatusCode
    , MissingContentHeader
    , InternalServerError
    ]
```

You may also omit the first newline.

```haskell
directions = [ North
             , East
             , South
             , West
             ]
```

Place pragmas after function definitions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Place pragmas immediately following the function they apply to.

Examples
^^^^^^^^
```haskell
id :: a -> a
id x = x
{-# INLINE id #-}
```

In the case of data type definitions, you must put the pragma before the
type it applies to.

Examples
^^^^^^^^
```haskell
data Array e = Array
    {-# UNPACK #-} !Int
    !ByteArray
```

Hanging lambdas
~~~~~~~~~~~~~~~

You may indent the code following a "hanging" lambda.

Examples
^^^^^^^^
[source,haskell]
bar :: IO ()
bar = forM_ [1, 2, 3] $ \n -> do
          putStrLn "Here comes a number!"
          print n

[source,haskell]
foo :: IO ()
foo = alloca 10 $ \a ->
      alloca 20 $ \b ->
      cFunction a b

Export lists
~~~~~~~~~~~~

Examples
^^^^^^^^
Format export lists as follows:

[source,haskell]
module Data.Set
    (
      -- * The @Set@ type
      Set
    , empty
    , singleton

      -- * Querying
    , member
    ) where

Prefer guards and pattern matches to if expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Guards and pattern matches should be preferred over if-then-else
expressions where possible. Short cases should be placed on a single line
when line length allows it.

When writing non-monadic code (that is, when not using `do`), and guards
and pattern matches cannot be used, align if-then-else expressions as
you would other expressions:

[source,haskell]
foo = if ...
      then ...
      else ...

Otherwise, be consistent with the four-space indent rule. Align the
`then` and `else` keywords. Some examples:

[source,haskell]
foo = do
    someCode
    if condition
        then someMoreCode
        else someAlternativeCode

[source,haskell]
foo = bar $ \qux -> if predicate qux
    then doSomethingSilly
    else someOtherCode

The same rule applies to nested `do` blocks:

[source,haskell]
foo = do
    instruction <- decodeInstruction
    skip <- load Memory.skip
    if skip == 0x0000
        then do
            execute instruction
            addCycles $ instructionCycles instruction
        else do
            store Memory.skip 0x0000
            addCycles 1

Case expressions
~~~~~~~~~~~~~~~~

* The alternatives in a `case` expression can either be indented using
  four spaces or be aligned to the `case` keyword.
* Align arrows (`->`) when it helps readability.

Examples
^^^^^^^^
[source,haskell]
foobar = case something of
    Just j  -> foo
    Nothing -> bar

[source,haskell]
foobar = case something of
             Just j  -> foo
             Nothing -> bar

Imports
-------

Group imported modules by origin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Imports should be grouped in the following order:

1. standard library imports
2. related third-party imports
3. local application or library specific imports

Separate import groups with a blank line
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Put a blank line between each group of imports.

Sort imports alphabetically
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The imports in each import group should be sorted alphabetically by
module name.

Qualify imports or explicitly list imported symbols
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Always use explicit import lists or `qualified` imports for modules from
standard and third-party libraries.

Rationale
^^^^^^^^^
This makes your code more robust against changes in imported modules.

Exceptions
^^^^^^^^^^
The `Prelude` does not need to be `qualified` or have an implicit import
list unless there is a namespace collision.

Comments
--------

Use Haddock syntax in comments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use [Haddock] syntax in comments.

Comment every exported definition
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Comment every top-level function&mdash;particularly exported functions.
* Provide a type signature for every top-level function.
* Comment every exported data type.
* For functions, the documentation should give enough information to apply
  the function without looking at the function's definition.

#### Examples
[source,haskell]
-- | Send a message on a socket. The socket must be in a connected state.
-- Returns the number of bytes sent. Applications are responsible for ensuring
-- that all data has been sent.
send :: Socket      -- ^ Connected socket
     -> ByteString  -- ^ Data to send
     -> IO Int      -- ^ Bytes sent

[source,haskell]
-- | Bla bla bla.
data Person = Person
    { age  :: !Int     -- ^ Age
    , name :: !String  -- ^ First name
    }

Format fields that require longer comments as follows:

[source,haskell]
data Record = Record
    { -- | This is a very very very long comment that is split over multiple
      -- lines.
      field1 :: !Text
      
      -- | This is a second very very very long comment that is split over
      -- multiple lines.
    , field2 :: !Int
    }

End-of-line comments
~~~~~~~~~~~~~~~~~~~~

* Place at least two spaces between a comment and any preceding code.
* Align comments for data type definitions.

Examples
^^^^^^^^
[source,haskell]
data Parser = Parser
    !Int         -- Current position
    !ByteString  -- Remaining input

[source,haskell]
foo :: Int -> Int
foo n = salt * 32 + 9
  where
    salt = 453645243  -- Magic hash salt.

Links
~~~~~

Use in-line links economically. You are encouraged to add links for API
names. It is not necessary to add links for all API names in a Haddock
comment. Only add a link to an API name when a user might want to click
on it. Only add links for the first occurrence of a name in a comment.

Names
-----

Use camel case for function names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use camel case when naming functions.

Examples
^^^^^^^^

* `functionName`

Rationale
^^^^^^^^^
Functions in Haskell must begin with a lower case letter.

Use upper camel case for type names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use upper camel case when naming data types and constructors.

Examples
^^^^^^^^

* `DataType`

Rationale
^^^^^^^^^
Data types and constructors in Haskell must begin with a capital letter.

Do not use all capitals for acronyms
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Only capitalize the first letter of acronyms.

Examples
^^^^^^^^
Write `HttpServer` instead of `HTTPServer`.

Rationale
^^^^^^^^^
Names containing adjacent capitals that belong to separate words may
hinder readability.

Exception
^^^^^^^^^
Two letter acronyms should have both letters capitalized&mdash;for
example, `IO`.

Use the singular for module names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Use the singular when naming modules.

Examples
^^^^^^^^
* Use `Data.Map` instead of `Data.Maps`.
* Use `Data.ByteString.Internal` instead of `Data.ByteString.Internals`.

Strictness
----------

By default, use strict data types and lazy functions.

Make data types strict by default
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Constructor fields should be strict unless there is an explicit reason
to make them lazy.

[source,haskell]
-- Good
data Point = Point
    { pointX :: !Double  -- ^ X coordinate
    , pointY :: !Double  -- ^ Y coordinate
    }

[source,haskell]
-- Bad
data Point = Point
    { pointX :: Double  -- ^ X coordinate
    , pointY :: Double  -- ^ Y coordinate
    }

Additionally, unpacking simple fields often improves performance and
reduces memory usage:

[source,haskell]
data Point = Point
    { pointX :: {-# UNPACK #-} !Double  -- ^ X coordinate
    , pointY :: {-# UNPACK #-} !Double  -- ^ Y coordinate
    }

As an alternative to the [`UNPACK`] pragma, you may place

[source,haskell]
{-# OPTIONS_GHC -funbox-strict-fields #-}

at the top of the file. Including this flag in the file itself instead
of in the `.cabal` file is preferable as the optimization will be
applied even if someone compiles the file using other means (in other
words, the optimization is attached to the source code it belongs to).

Note that [`-funbox-strict-fields`] applies to all strict fields, not
just small fields such as `Double` or `Int`. If you are using GHC 7.4 or
later, you can use [`NOUNPACK`] to selectively opt-out for the unpacking
enabled by `-funbox-strict-fields`.

[`UNPACK`]: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#unpack-pragma
[`-funbox-strict-fields`]: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#options-f-compact
[`NOUNPACK`]: http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html#nounpack-pragma

Rationale
^^^^^^^^^
This avoids many common pitfalls caused by too much laziness and reduces
the amount of time the programmer has to spend thinking about evaluation
order.

Make function arguments lazy by default
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Make function arguments lazy unless you explicitly need them to be
strict.

Examples
^^^^^^^^
The most common case when you need strict function arguments is in
recursion with an accumulator:

[source,haskell]
mysum :: [Int] -> Int
mysum = go 0
  where
    go !acc []      = acc
    go acc (x : xs) = go (acc + x) xs

Miscellaneous
-------------

Avoid over-using point-free style
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[Point-free style] should be avoided when it inhibits readability.

[Point-free style]: http://www.haskell.org/haskellwiki/Pointfree

Examples
^^^^^^^^
Prefer `f x = g . h x` to `f = (g .) . h`, which is harder to read.

Code must be warning-free
~~~~~~~~~~~~~~~~~~~~~~~~~

Code must not produce warnings when compiled with [`-Wall`].

[`-Wall`]: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html

Rationale
^^^^^^^^^
Ignoring warnings that are false positives or benign can eventually
make it difficult to identify warnings that are serious.

Do not escape newlines in strings
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Escaped newlines will make using the [`CPP`] language extension
impossible.

[`CPP`]: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#c-pre-processor


[Haddock]: http://www.haskell.org/haddock/
